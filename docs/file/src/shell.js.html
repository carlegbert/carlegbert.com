<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/shell.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/carlegbert/wwwterm" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fileobject.js~DirFile.html">DirFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fileobject.js~FileObject.html">FileObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fileobject.js~TxtFile.html">TxtFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shell-command.js~ShellCommand.html">ShellCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shell-command.js~ShellCommandResult.html">ShellCommandResult</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shell.js~Shell.html">Shell</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vi.js~Vi.html">Vi</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getChar">getChar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-print">print</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-printInline">printInline</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/shell.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint-env jquery */

import { getChar, print, printInline } from &apos;./io&apos;;
import { TxtFile, DirFile } from &apos;./fileobject&apos;;
import { ShellCommand, ShellCommandResult } from &apos;./shell-command&apos;;
import Vi from &apos;./vi&apos;;

/**
 * Object encapsulating shell session
 * @class
 */
export default class Shell {
  /**
   * Represents shell session. to be instantiated once upon browser load.
   * @constructor
   * @param {DirFile} fileStructure base dir tied to shell session
   */
  constructor(fileStructure) {
    /**
     * @type {DirFile}
     */
    this.fileStructure = fileStructure;
    /**
     * @type {DirFile}
     */
    this.currentDir = fileStructure;
    /**
     * @type {string}
     */
    this.user = &apos;guest&apos;;
    /**
     * @type {string}
     */
    this.inputString = &apos;&apos;;
    /**
     * @type {string[]}
     */
    this.bashHistory = [];
    /**
     * @type {number}
     */
    this.historyIndex = 0;
    /**
     * @type {boolean}
     */
    this.tabPressed = false;
    /**
     * @type {HTMLElement}
     */
    this.inputPromptElement = $(&apos;#input&apos;);
    /**
     * @type {HTMLElement}
     */
    this.PS1Element = $(&apos;#PS1&apos;);
    /**
     * @type {HTMLElement}
     */
    this.outputElement = $(&apos;#terminal-output&apos;);
    /**
     * @type {Object} - TODO: create base Process class
     */
    this.childProcess = null;
  }

  /**
   * @return {string} PS1 string
   */
  getPS1String() {
    return `&lt;span class=&quot;user&quot;&gt;${this.user}@www.carlegbert.com:&lt;/span&gt;` +
      `&lt;span class=&quot;path&quot;&gt;${this.currentDir.fullPath}&lt;/span&gt;$&amp;nbsp;`;
  }

  /**
   * Direct keystroke to shell&apos;s keystroke handler or to child process
   * if there is one active
   * @param {Object} event Keystroke event
   */
  parseKeystroke(event) {
    if (!this.childProcess) this.shellKeystroke(event);
    else this.childProcess.parseKeystroke(event);
  }

  /**
   * Process keystroke
   * @param {Object} event Keystroke event
   */
  shellKeystroke(event) {
    if (event.which === 13) { // enter
      this.tabPressed = false;
      event.preventDefault();
      this.handleEnter();
    } else if (event.which === 8) { // backspace
      this.tabPressed = false;
      event.preventDefault();
      this.inputString = this.inputString.slice(0, (this.inputString.length - 1));
      this.inputPromptElement.html(this.inputString.replace(/ /g, &apos;&amp;nbsp;&apos;));
    } else if (event.which === 38 &amp;&amp; this.historyIndex &gt; 0) { // up arrow
      this.tabPressed = false;
      event.preventDefault();
      this.historyIndex -= 1;
      this.inputString = this.bashHistory[this.historyIndex];
      this.inputPromptElement.html(this.inputString);
    } else if (event.which === 40 &amp;&amp; this.historyIndex &lt; this.bashHistory.length) { // down
      this.tabPressed = false;
      event.preventDefault();
      this.historyIndex += 1;
      if (this.historyIndex === this.bashHistory.length) this.inputString = &apos;&apos;;
      else this.inputString = this.bashHistory[this.historyIndex];
      this.inputPromptElement.html(this.inputString);
    } else if (event.which === 9) { // tab
      event.preventDefault();
      this.handleTab();
    } else {
      this.tabPressed = false;
      const k = getChar(event);
      this.inputString += k;
      const kSpaceAdjusted = k === &apos; &apos; ? &apos;&amp;nbsp;&apos; : k;
      this.inputPromptElement.append(kSpaceAdjusted);
    }
    this.inputPromptElement[0].scrollIntoView(false);
  }

  /**
   * process Enter keystroke
   */
  handleEnter() {
    if (!this.inputString.match(/[^ ]/g)) { // regex for anything but space
      print(this.getPS1String(), this.outputElement);
    } else {
      print(this.getPS1String() + this.inputString.replace(&apos; &apos;, &apos;&amp;nbsp;&apos;), this.outputElement);
      this.bashHistory.push(this.inputString);
      const res = this.executeCommand(this.inputString);
      print(res.getDefaultOutput(), this.outputElement);
    }
    this.inputString = &apos;&apos;;
    this.inputPromptElement.html(&apos;&apos;);
    this.historyIndex = this.bashHistory.length;
  }

  /**
   * attempt to process inputstring into shell command
   * @param {string} inputString String to process
   * @return {Object} Result of eval(evalStr), which should always
   * be a ShellCommandResult object
   */
  executeCommand(inputString) {
    if (inputString.includes(&apos;&gt;&gt;&apos;)) return this.redirect(inputString, &apos;&gt;&gt;&apos;);
    if (inputString.includes(&apos;&gt;&apos;)) return this.redirect(inputString, &apos;&gt;&apos;);

    const shellCommand = new ShellCommand(inputString);
    if (!Shell.validCommands().includes(shellCommand.command)) {
      return new ShellCommandResult([], `${shellCommand.command}: command not found`);
    }
    const evalStr = `this.${shellCommand.command}(shellCommand)`;
    return eval(evalStr);
  }

  /**
   * redirect with &gt;, &gt;&gt; operators
   * @param {string} inputString Input string containing redirect operator
   * @param {string} pattern Redirect operator (either &gt; or &gt;&gt;)
   * @return {Object} ShellCommandResult containing stderr to print to screen if necessary
   */
  redirect(inputString, pattern) {
    const i = inputString.indexOf(pattern);
    const afterSymbol = inputString.slice(i + pattern.length).trim().split(&apos; &apos;);
    if (!afterSymbol || afterSymbol.length === 0) return new ShellCommandResult([], &apos;Syntax error&apos;);
    const otherArgs = afterSymbol.length === 1 ? [] : afterSymbol.slice(pattern.length);
    const newInput = inputString.slice(0, i) + otherArgs.join(&apos; &apos;);
    const res = this.executeCommand(newInput);
    const filepath = afterSymbol[0];
    const file = this.findFile(this.currentDir, [filepath], &apos;txt&apos;) || this.newFile([filepath], &apos;txt&apos;).data;
    if (!file) return new ShellCommandResult(null, `bash: ${filepath}: No such file or directory`);
    file.contents = pattern === &apos;&gt;&apos; ? res.stdOut : file.contents.concat(res.stdOut);
    return new ShellCommandResult(null, res.stdErr);
  }

  /**
   * handle tab for autocompletion
   */
  handleTab() {
    const spaceAtEnd = (this.inputString[this.inputString.length - 1] === &apos; &apos;);
    const cmd = new ShellCommand(this.inputString);
    let options;
    let partial;
    if (!cmd.command) {
      partial = &apos;&apos;;
      options = Shell.validCommands();
    } else if (!spaceAtEnd &amp;&amp; cmd.args.length === 0) {
      partial = cmd.command;
      options = Shell.filterAutoCompleteOptions(partial, Shell.validCommands());
    } else {
      partial = cmd.args[cmd.args.length - 1] || &apos;&apos;;
      options = this.getAutocompleteFiles(partial, Shell.getValidTypes(cmd.command));
      if (options.length === 0) options = this.getAutocompleteFiles(partial, [&apos;dir&apos;]);
    }
    if (options.length === 1) this.executeAutoComplete(partial, options[0]);
    else if (options.length &gt; 1) this.printAutoCompleteOptions(options);
  }

  /**
   * filter array of strings into options that match up with partial argument
   * @param {string} partial String to be autocompleted
   * @param {string[]} options List of files or commands to check against partial
   * @return {string[]} Array of strings from options that match against partial
   */
  static filterAutoCompleteOptions(partial, options) {
    const len = partial.length;
    const validOptions = [];
    options.forEach((opt) =&gt; {
      if (opt.length &gt;= len &amp;&amp; opt.slice(0, len) === partial) {
        validOptions.push(opt);
      }
    });
    return validOptions;
  }

  /**
   * returns list of all files in a directory for autocompletion purposes.
   * @param {string} partial Filepath to be completed, eg, &apos;path/to/fi&apos; or &apos;pat&apos;
   * @param {string[]} filetypes Optional filetypes to filter for
   * @return {string[]} array of filenames
   */
  getAutocompleteFiles(partial, filetypes) {
    const partialAsArray = partial.split(&apos;/&apos;);
    const partialName = partialAsArray.slice(-1)[0];
    const dirPath = partialAsArray.slice(0, -1);
    const dir = this.findFile(this.currentDir, dirPath, &apos;dir&apos;);
    const fileOptions = dir.getContentsByTypes(filetypes);
    const options = [];
    fileOptions.forEach((f) =&gt; {
      let optName = f.name;
      if (f.filetype === &apos;dir&apos;) optName += &apos;/&apos;;
      options.push(optName);
    });
    return Shell.filterAutoCompleteOptions(partialName, options);
  }

  /**
   * prints valid autocomplete options. to be called only if there are multiple options.
   * @param {string[]} options Options to print
   */
  printAutoCompleteOptions(options) {
    if (this.tabPressed) {
      print(this.getPS1String() + this.inputString, this.outputElement);
      printInline(options, this.outputElement);
    } else {
      this.tabPressed = true;
    }
  }

  /**
   * executes autocomplete. to be called only if there is one valid autocomplete option.
   * @param {string} partial Word to be completed
   * @param {string} complete Word to be autocompleted to
   */
  executeAutoComplete(partial, complete) {
    const splitPartial = partial.split(&apos;/&apos;);
    const wordPartial = splitPartial[splitPartial.length - 1];
    const completion = complete.slice(wordPartial.length);
    this.inputString += completion;
    this.inputPromptElement.append(completion);
  }

  /**
   * Function to find file in a directory. Returns null if unsuccesful; it is the responsibility
   * of the calling function to otherwise deal with failure.
   *
   * @param {DirFile} dir Directory to find file in
   * @param {string[]} filepath Path to file to be found
   * @param {string} filetype Type of file to find (optional)
   * @return {FileObject} Returns file object if found, null if not
   */
  findFile(dir, filepath, filetype) {
    if ((filepath.length === 0 || (filepath.length === 1 &amp;&amp; filepath[0] === &apos;&apos;))
        &amp;&amp; filetype === &apos;dir&apos;) return dir;
    let found = null;
    const pathArg = filepath[0];
    const typeToFind = filepath.length === 1 ? filetype : &apos;dir&apos;;
    switch (pathArg) {
      case &apos;.&apos;:
        found = dir;
        break;
      case &apos;..&apos;:
        found = dir.parentRef;
        break;
      case &apos;~&apos;:
        found = this.fileStructure;
        break;
      default:
        dir.children.forEach((child) =&gt; {
          if (pathArg === child.name &amp;&amp; (!typeToFind || typeToFind === child.filetype)) {
            found = child;
          }
        });
    }

    if (filepath.length === 1 || !found) return found;
    return this.findFile(found, filepath.slice(1), filetype);
  }

  /**
   * create new file
   * @param {string} filepath Path to file from working directory, including name of new file
   * @param {string} filetype Type of file (dir, txt)
   * @return {ShellCommandResult} ShellCommandResult object with ref to file or stderr string
   */
  newFile(filepath, filetype) {
    let dir;
    if (filepath.length === 1) dir = this.currentDir;
    else dir = this.findFile(this.currentDir, filepath.slice(0, -1), &apos;dir&apos;);
    if (!dir) return new ShellCommandResult(null, `${filepath.slice(0, -1).join(&apos;/&apos;)}: Directory not found`);
    const filename = filepath.slice(-1)[0];
    const pathStr = `${dir.fullPath}/${filename}`;
    let file;
    if (filetype === &apos;dir&apos;) file = new DirFile(filename, pathStr, filetype, dir);
    else file = new TxtFile(filename, pathStr, filetype, dir);
    dir.children.push(file);
    return new ShellCommandResult(null, null, file);
  }

  killChildProcess() {
    this.childProcess = null;
  }

  // Shell Commands
  // TODO: should these be moved to seperate class, or to ShellCommand class?

  /**
   * List of all valid commands, used for autocompletion and to validate ShellCommand
   * objects before using eval
   * @return {string[]} List of valid commands that can be executed
   */
  static validCommands() {
    return [
      &apos;clear&apos;,
      &apos;pwd&apos;,
      &apos;whoami&apos;,
      &apos;cd&apos;,
      &apos;ls&apos;,
      &apos;cat&apos;,
      &apos;touch&apos;,
      &apos;mkdir&apos;,
      &apos;echo&apos;,
      &apos;vi&apos;,
    ];
  }

  /**
   * Determine valid filetypes for command arguments
   * @param {string} cmdName Command name, eg, &apos;ls&apos;, &apos;cat&apos;, etc
   * @return {string[]} array of valid filetypes
   */
  static getValidTypes(cmdName) {
    const typeDict = {
      ls: [&apos;dir&apos;],
      cd: [&apos;dir&apos;],
      mkdir: [&apos;dir&apos;],
      cat: [&apos;txt&apos;],
      &apos;&gt;&apos;: [&apos;txt&apos;],
      vi: [&apos;txt&apos;],
    };
    return typeDict[cmdName] || [&apos;dir&apos;, &apos;txt&apos;];
  }


  /**
   * Clear #terminal-output. Removes elemnts from DOM rather than just scrolling.
   * @return {ShellCommandResult}
   */
  clear() {
    $(&apos;#terminal-output&apos;).html(&apos;&apos;);
    return new ShellCommandResult();
  }

  /**
   * Get current directory
   * @return {ShellCommandResult}
   */
  pwd() {
    return new ShellCommandResult(this.currentDir.fullPath);
  }

  /**
   * Get current user
   * @return {ShellCommandResult}
   */
  whoami() {
    return new ShellCommandResult(this.user);
  }

  /**
   * Change directory
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  cd(shellCommand) {
    const dir = shellCommand.args.length === 0 ? this.fileStructure :
      this.findFile(this.currentDir, shellCommand.args[0].split(&apos;/&apos;), &apos;dir&apos;);
    if (dir) {
      this.currentDir = dir;
      this.PS1Element.html(this.getPS1String());
      return new ShellCommandResult();
    }
    return new ShellCommandResult(null, `${shellCommand.args[0]}: directory not found`);
  }

  /**
   * List contents of directory/directories
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  ls(shellCommand) {
    const res = new ShellCommandResult([]);
    if (shellCommand.args.length === 0) {
      res.stdOut.push(this.currentDir.lsHelper());
    } else {
      shellCommand.args.forEach((arg) =&gt; {
        const dir = this.findFile(this.currentDir, arg.split(&apos;/&apos;), &apos;dir&apos;);
        if (!dir) {
          res.stdErr.push(`ls: cannot access ${arg}: no such file or directory`);
        } else {
          let str = &apos;&apos;;
          if (shellCommand.args.length &gt; 1) str += `${arg}:`;
          str += dir.lsHelper();
          res.stdOut.push(str);
        }
      });
    }
    return res;
  }


  /**
   * List contents of text file(s)
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  cat(shellCommand) {
    const res = new ShellCommandResult();
    if (shellCommand.args.length === 0) return res;
    shellCommand.args.forEach((arg) =&gt; {
      const path = arg.split(&apos;/&apos;);
      const file = this.findFile(this.currentDir, path);
      if (file &amp;&amp; file.filetype === &apos;dir&apos;) {
        res.stdErr.push(`cat: ${file.name}: Is a directory`);
      } else if (file) {
        res.stdOut = res.stdOut.concat(file.contents);
      } else {
        res.stdErr.push(`cat: ${arg}: No such file or directory`);
      }
    });
    return res;
  }

  /**
   * Mark file or directory as modified. Create new file if one doesn&apos;t exist at path.
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  touch(shellCommand) {
    const res = new ShellCommandResult();
    if (shellCommand.args.length === 0) return res;
    shellCommand.args.forEach((arg) =&gt; {
      const path = arg.split(&apos;/&apos;);
      const file = this.findFile(this.currentDir, path, &apos;txt&apos;);
      if (file) file.lastModified = new Date();
      else {
        const newFileRes = this.newFile(path, &apos;txt&apos;);
        res.combine(newFileRes);
      }
    });
    return res;
  }

  /**
   * Create new directory
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  mkdir(shellCommand) {
    const res = new ShellCommandResult();
    if (shellCommand.args.length === 0) return res;
    shellCommand.args.forEach((arg) =&gt; {
      const path = arg.split(&apos;/&apos;);
      const file = this.findFile(this.currentDir, path, &apos;dir&apos;);
      if (!file) {
        const newFileRes = this.newFile(path, &apos;dir&apos;);
        res.combine(newFileRes);
      }
    });
    return res;
  }

  /**
   * Print text
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  echo(shellCommand) {
    const output = shellCommand.args.join(&apos; &apos;);
    return new ShellCommandResult(output);
  }

  /**
   * Start new vi session
   * @param {ShellCommand} shellCommand
   * @return {ShellCommandResult}
   */
  vi(shellCommand) {
    const fPath = shellCommand.args[0].split(&apos;/&apos;);
    const file = this.findFile(this.currentDir, fPath, &apos;txt&apos;);
    this.childProcess = new Vi(this, fPath, file);
    return new ShellCommandResult();
  }

}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
